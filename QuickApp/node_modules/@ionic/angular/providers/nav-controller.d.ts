import { Location } from '@angular/common';
import { NavigationExtras, Router, UrlSerializer, UrlTree } from '@angular/router';
import { AnimationBuilder, NavDirection, RouterDirection } from '@ionic/core';
import { IonRouterOutlet } from '../directives/navigation/ion-router-outlet';
import { Platform } from './platform';
import * as ɵngcc0 from '@angular/core';
export interface AnimationOptions {
    animated?: boolean;
    animation?: AnimationBuilder;
    animationDirection?: 'forward' | 'back';
}
export interface NavigationOptions extends NavigationExtras, AnimationOptions {
}
export declare class NavController {
    private location;
    private serializer;
    private router?;
    private topOutlet?;
    private direction;
    private animated?;
    private animationBuilder?;
    private guessDirection;
    private guessAnimation?;
    private lastNavId;
    constructor(platform: Platform, location: Location, serializer: UrlSerializer, router?: Router);
    /**
     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,
     * it's equivalent to calling `this.router.navigateByUrl()`, but it's explicit about the **direction** of the transition.
     *
     * Going **forward** means that a new page is going to be pushed to the stack of the outlet (ion-router-outlet),
     * and that it will show a "forward" animation by default.
     *
     * Navigating forward can also be triggered in a declarative manner by using the `[routerDirection]` directive:
     *
     * ```html
     * <a routerLink="/path/to/page" routerDirection="forward">Link</a>
     * ```
     */
    navigateForward(url: string | UrlTree | any[], options?: NavigationOptions): Promise<boolean>;
    /**
     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,
     * it's equivalent to calling:
     *
     * ```ts
     * this.navController.setDirection('back');
     * this.router.navigateByUrl(path);
     * ```
     *
     * Going **back** means that all the pages in the stack until the navigated page is found will be popped,
     * and that it will show a "back" animation by default.
     *
     * Navigating back can also be triggered in a declarative manner by using the `[routerDirection]` directive:
     *
     * ```html
     * <a routerLink="/path/to/page" routerDirection="back">Link</a>
     * ```
     */
    navigateBack(url: string | UrlTree | any[], options?: NavigationOptions): Promise<boolean>;
    /**
     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,
     * it's equivalent to calling:
     *
     * ```ts
     * this.navController.setDirection('root');
     * this.router.navigateByUrl(path);
     * ```
     *
     * Going **root** means that all existing pages in the stack will be removed,
     * and the navigated page will become the single page in the stack.
     *
     * Navigating root can also be triggered in a declarative manner by using the `[routerDirection]` directive:
     *
     * ```html
     * <a routerLink="/path/to/page" routerDirection="root">Link</a>
     * ```
     */
    navigateRoot(url: string | UrlTree | any[], options?: NavigationOptions): Promise<boolean>;
    /**
     * Same as [Location](https://angular.io/api/common/Location)'s back() method.
     * It will use the standard `window.history.back()` under the hood, but featuring a `back` animation
     * by default.
     */
    back(options?: AnimationOptions): void;
    /**
     * This methods goes back in the context of Ionic's stack navigation.
     *
     * It recursively finds the top active `ion-router-outlet` and calls `pop()`.
     * This is the recommended way to go back when you are using `ion-router-outlet`.
     */
    pop(): Promise<void>;
    /**
     * This methods specifies the direction of the next navigation performed by the Angular router.
     *
     * `setDirection()` does not trigger any transition, it just sets some flags to be consumed by `ion-router-outlet`.
     *
     * It's recommended to use `navigateForward()`, `navigateBack()` and `navigateRoot()` instead of `setDirection()`.
     */
    setDirection(direction: RouterDirection, animated?: boolean, animationDirection?: 'forward' | 'back', animationBuilder?: AnimationBuilder): void;
    /**
     * @internal
     */
    setTopOutlet(outlet: IonRouterOutlet): void;
    /**
     * @internal
     */
    consumeTransition(): {
        direction: RouterDirection;
        animation: NavDirection;
        animationBuilder: AnimationBuilder;
    };
    private navigate;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NavController, [null, null, null, { optional: true; }]>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<NavController>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF2LWNvbnRyb2xsZXIuZC50cyIsInNvdXJjZXMiOlsibmF2LWNvbnRyb2xsZXIuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMb2NhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOYXZpZ2F0aW9uRXh0cmFzLCBSb3V0ZXIsIFVybFNlcmlhbGl6ZXIsIFVybFRyZWUgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgQW5pbWF0aW9uQnVpbGRlciwgTmF2RGlyZWN0aW9uLCBSb3V0ZXJEaXJlY3Rpb24gfSBmcm9tICdAaW9uaWMvY29yZSc7XG5pbXBvcnQgeyBJb25Sb3V0ZXJPdXRsZXQgfSBmcm9tICcuLi9kaXJlY3RpdmVzL25hdmlnYXRpb24vaW9uLXJvdXRlci1vdXRsZXQnO1xuaW1wb3J0IHsgUGxhdGZvcm0gfSBmcm9tICcuL3BsYXRmb3JtJztcbmV4cG9ydCBpbnRlcmZhY2UgQW5pbWF0aW9uT3B0aW9ucyB7XG4gICAgYW5pbWF0ZWQ/OiBib29sZWFuO1xuICAgIGFuaW1hdGlvbj86IEFuaW1hdGlvbkJ1aWxkZXI7XG4gICAgYW5pbWF0aW9uRGlyZWN0aW9uPzogJ2ZvcndhcmQnIHwgJ2JhY2snO1xufVxuZXhwb3J0IGludGVyZmFjZSBOYXZpZ2F0aW9uT3B0aW9ucyBleHRlbmRzIE5hdmlnYXRpb25FeHRyYXMsIEFuaW1hdGlvbk9wdGlvbnMge1xufVxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmF2Q29udHJvbGxlciB7XG4gICAgcHJpdmF0ZSBsb2NhdGlvbjtcbiAgICBwcml2YXRlIHNlcmlhbGl6ZXI7XG4gICAgcHJpdmF0ZSByb3V0ZXI/O1xuICAgIHByaXZhdGUgdG9wT3V0bGV0PztcbiAgICBwcml2YXRlIGRpcmVjdGlvbjtcbiAgICBwcml2YXRlIGFuaW1hdGVkPztcbiAgICBwcml2YXRlIGFuaW1hdGlvbkJ1aWxkZXI/O1xuICAgIHByaXZhdGUgZ3Vlc3NEaXJlY3Rpb247XG4gICAgcHJpdmF0ZSBndWVzc0FuaW1hdGlvbj87XG4gICAgcHJpdmF0ZSBsYXN0TmF2SWQ7XG4gICAgY29uc3RydWN0b3IocGxhdGZvcm06IFBsYXRmb3JtLCBsb2NhdGlvbjogTG9jYXRpb24sIHNlcmlhbGl6ZXI6IFVybFNlcmlhbGl6ZXIsIHJvdXRlcj86IFJvdXRlcik7XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgdXNlcyBBbmd1bGFyJ3MgW1JvdXRlcl0oaHR0cHM6Ly9hbmd1bGFyLmlvL2FwaS9yb3V0ZXIvUm91dGVyKSB1bmRlciB0aGUgaG9vZCxcbiAgICAgKiBpdCdzIGVxdWl2YWxlbnQgdG8gY2FsbGluZyBgdGhpcy5yb3V0ZXIubmF2aWdhdGVCeVVybCgpYCwgYnV0IGl0J3MgZXhwbGljaXQgYWJvdXQgdGhlICoqZGlyZWN0aW9uKiogb2YgdGhlIHRyYW5zaXRpb24uXG4gICAgICpcbiAgICAgKiBHb2luZyAqKmZvcndhcmQqKiBtZWFucyB0aGF0IGEgbmV3IHBhZ2UgaXMgZ29pbmcgdG8gYmUgcHVzaGVkIHRvIHRoZSBzdGFjayBvZiB0aGUgb3V0bGV0IChpb24tcm91dGVyLW91dGxldCksXG4gICAgICogYW5kIHRoYXQgaXQgd2lsbCBzaG93IGEgXCJmb3J3YXJkXCIgYW5pbWF0aW9uIGJ5IGRlZmF1bHQuXG4gICAgICpcbiAgICAgKiBOYXZpZ2F0aW5nIGZvcndhcmQgY2FuIGFsc28gYmUgdHJpZ2dlcmVkIGluIGEgZGVjbGFyYXRpdmUgbWFubmVyIGJ5IHVzaW5nIHRoZSBgW3JvdXRlckRpcmVjdGlvbl1gIGRpcmVjdGl2ZTpcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8YSByb3V0ZXJMaW5rPVwiL3BhdGgvdG8vcGFnZVwiIHJvdXRlckRpcmVjdGlvbj1cImZvcndhcmRcIj5MaW5rPC9hPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIG5hdmlnYXRlRm9yd2FyZCh1cmw6IHN0cmluZyB8IFVybFRyZWUgfCBhbnlbXSwgb3B0aW9ucz86IE5hdmlnYXRpb25PcHRpb25zKTogUHJvbWlzZTxib29sZWFuPjtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB1c2VzIEFuZ3VsYXIncyBbUm91dGVyXShodHRwczovL2FuZ3VsYXIuaW8vYXBpL3JvdXRlci9Sb3V0ZXIpIHVuZGVyIHRoZSBob29kLFxuICAgICAqIGl0J3MgZXF1aXZhbGVudCB0byBjYWxsaW5nOlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiB0aGlzLm5hdkNvbnRyb2xsZXIuc2V0RGlyZWN0aW9uKCdiYWNrJyk7XG4gICAgICogdGhpcy5yb3V0ZXIubmF2aWdhdGVCeVVybChwYXRoKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEdvaW5nICoqYmFjayoqIG1lYW5zIHRoYXQgYWxsIHRoZSBwYWdlcyBpbiB0aGUgc3RhY2sgdW50aWwgdGhlIG5hdmlnYXRlZCBwYWdlIGlzIGZvdW5kIHdpbGwgYmUgcG9wcGVkLFxuICAgICAqIGFuZCB0aGF0IGl0IHdpbGwgc2hvdyBhIFwiYmFja1wiIGFuaW1hdGlvbiBieSBkZWZhdWx0LlxuICAgICAqXG4gICAgICogTmF2aWdhdGluZyBiYWNrIGNhbiBhbHNvIGJlIHRyaWdnZXJlZCBpbiBhIGRlY2xhcmF0aXZlIG1hbm5lciBieSB1c2luZyB0aGUgYFtyb3V0ZXJEaXJlY3Rpb25dYCBkaXJlY3RpdmU6XG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGEgcm91dGVyTGluaz1cIi9wYXRoL3RvL3BhZ2VcIiByb3V0ZXJEaXJlY3Rpb249XCJiYWNrXCI+TGluazwvYT5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBuYXZpZ2F0ZUJhY2sodXJsOiBzdHJpbmcgfCBVcmxUcmVlIHwgYW55W10sIG9wdGlvbnM/OiBOYXZpZ2F0aW9uT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj47XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgdXNlcyBBbmd1bGFyJ3MgW1JvdXRlcl0oaHR0cHM6Ly9hbmd1bGFyLmlvL2FwaS9yb3V0ZXIvUm91dGVyKSB1bmRlciB0aGUgaG9vZCxcbiAgICAgKiBpdCdzIGVxdWl2YWxlbnQgdG8gY2FsbGluZzpcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogdGhpcy5uYXZDb250cm9sbGVyLnNldERpcmVjdGlvbigncm9vdCcpO1xuICAgICAqIHRoaXMucm91dGVyLm5hdmlnYXRlQnlVcmwocGF0aCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBHb2luZyAqKnJvb3QqKiBtZWFucyB0aGF0IGFsbCBleGlzdGluZyBwYWdlcyBpbiB0aGUgc3RhY2sgd2lsbCBiZSByZW1vdmVkLFxuICAgICAqIGFuZCB0aGUgbmF2aWdhdGVkIHBhZ2Ugd2lsbCBiZWNvbWUgdGhlIHNpbmdsZSBwYWdlIGluIHRoZSBzdGFjay5cbiAgICAgKlxuICAgICAqIE5hdmlnYXRpbmcgcm9vdCBjYW4gYWxzbyBiZSB0cmlnZ2VyZWQgaW4gYSBkZWNsYXJhdGl2ZSBtYW5uZXIgYnkgdXNpbmcgdGhlIGBbcm91dGVyRGlyZWN0aW9uXWAgZGlyZWN0aXZlOlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxhIHJvdXRlckxpbms9XCIvcGF0aC90by9wYWdlXCIgcm91dGVyRGlyZWN0aW9uPVwicm9vdFwiPkxpbms8L2E+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgbmF2aWdhdGVSb290KHVybDogc3RyaW5nIHwgVXJsVHJlZSB8IGFueVtdLCBvcHRpb25zPzogTmF2aWdhdGlvbk9wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+O1xuICAgIC8qKlxuICAgICAqIFNhbWUgYXMgW0xvY2F0aW9uXShodHRwczovL2FuZ3VsYXIuaW8vYXBpL2NvbW1vbi9Mb2NhdGlvbikncyBiYWNrKCkgbWV0aG9kLlxuICAgICAqIEl0IHdpbGwgdXNlIHRoZSBzdGFuZGFyZCBgd2luZG93Lmhpc3RvcnkuYmFjaygpYCB1bmRlciB0aGUgaG9vZCwgYnV0IGZlYXR1cmluZyBhIGBiYWNrYCBhbmltYXRpb25cbiAgICAgKiBieSBkZWZhdWx0LlxuICAgICAqL1xuICAgIGJhY2sob3B0aW9ucz86IEFuaW1hdGlvbk9wdGlvbnMpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kcyBnb2VzIGJhY2sgaW4gdGhlIGNvbnRleHQgb2YgSW9uaWMncyBzdGFjayBuYXZpZ2F0aW9uLlxuICAgICAqXG4gICAgICogSXQgcmVjdXJzaXZlbHkgZmluZHMgdGhlIHRvcCBhY3RpdmUgYGlvbi1yb3V0ZXItb3V0bGV0YCBhbmQgY2FsbHMgYHBvcCgpYC5cbiAgICAgKiBUaGlzIGlzIHRoZSByZWNvbW1lbmRlZCB3YXkgdG8gZ28gYmFjayB3aGVuIHlvdSBhcmUgdXNpbmcgYGlvbi1yb3V0ZXItb3V0bGV0YC5cbiAgICAgKi9cbiAgICBwb3AoKTogUHJvbWlzZTx2b2lkPjtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZHMgc3BlY2lmaWVzIHRoZSBkaXJlY3Rpb24gb2YgdGhlIG5leHQgbmF2aWdhdGlvbiBwZXJmb3JtZWQgYnkgdGhlIEFuZ3VsYXIgcm91dGVyLlxuICAgICAqXG4gICAgICogYHNldERpcmVjdGlvbigpYCBkb2VzIG5vdCB0cmlnZ2VyIGFueSB0cmFuc2l0aW9uLCBpdCBqdXN0IHNldHMgc29tZSBmbGFncyB0byBiZSBjb25zdW1lZCBieSBgaW9uLXJvdXRlci1vdXRsZXRgLlxuICAgICAqXG4gICAgICogSXQncyByZWNvbW1lbmRlZCB0byB1c2UgYG5hdmlnYXRlRm9yd2FyZCgpYCwgYG5hdmlnYXRlQmFjaygpYCBhbmQgYG5hdmlnYXRlUm9vdCgpYCBpbnN0ZWFkIG9mIGBzZXREaXJlY3Rpb24oKWAuXG4gICAgICovXG4gICAgc2V0RGlyZWN0aW9uKGRpcmVjdGlvbjogUm91dGVyRGlyZWN0aW9uLCBhbmltYXRlZD86IGJvb2xlYW4sIGFuaW1hdGlvbkRpcmVjdGlvbj86ICdmb3J3YXJkJyB8ICdiYWNrJywgYW5pbWF0aW9uQnVpbGRlcj86IEFuaW1hdGlvbkJ1aWxkZXIpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHNldFRvcE91dGxldChvdXRsZXQ6IElvblJvdXRlck91dGxldCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3VtZVRyYW5zaXRpb24oKToge1xuICAgICAgICBkaXJlY3Rpb246IFJvdXRlckRpcmVjdGlvbjtcbiAgICAgICAgYW5pbWF0aW9uOiBOYXZEaXJlY3Rpb247XG4gICAgICAgIGFuaW1hdGlvbkJ1aWxkZXI6IEFuaW1hdGlvbkJ1aWxkZXI7XG4gICAgfTtcbiAgICBwcml2YXRlIG5hdmlnYXRlO1xufVxuIl19